diff -urN original/fs/f2fs/f2fs.h modified/fs/f2fs/f2fs.h
--- original/fs/f2fs/f2fs.h	2018-01-22 15:41:02.346194462 +0900
+++ modified/fs/f2fs/f2fs.h	2018-01-30 21:51:15.439794085 +0900
@@ -25,6 +25,8 @@
 #include <linux/fscrypto.h>
 #include <crypto/hash.h>
 
+#define F2FS_MUFIT
+
 #ifdef CONFIG_F2FS_CHECK_FS
 #define f2fs_bug_on(sbi, condition)	BUG_ON(condition)
 #else
@@ -262,6 +264,20 @@
 #define F2FS_IOCTL_MAGIC		0xf5
 #define F2FS_IOC_START_ATOMIC_WRITE	_IO(F2FS_IOCTL_MAGIC, 1)
 #define F2FS_IOC_COMMIT_ATOMIC_WRITE	_IO(F2FS_IOCTL_MAGIC, 2)
+#ifdef F2FS_MUFIT
+#define F2FS_IOC_ADD_ATOMIC_FILE        _IO(F2FS_IOCTL_MAGIC, 3)
+#define F2FS_IOC_START_ATOMIC_WRITE_FILES   _IO(F2FS_IOCTL_MAGIC, 4)
+#define F2FS_IOC_COMMIT_ATOMIC_WRITE_FILES  _IO(F2FS_IOCTL_MAGIC, 5)
+#define F2FS_IOC_END_ATOMIC_WRITE_FILES _IO(F2FS_IOCTL_MAGIC, 6)
+#define F2FS_IOC_START_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 7)
+#define F2FS_IOC_RELEASE_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 8)
+#define F2FS_IOC_ABORT_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 9)
+#define F2FS_IOC_GARBAGE_COLLECT	_IO(F2FS_IOCTL_MAGIC, 10)
+#define F2FS_IOC_WRITE_CHECKPOINT	_IO(F2FS_IOCTL_MAGIC, 11)
+#define F2FS_IOC_DEFRAGMENT		_IO(F2FS_IOCTL_MAGIC, 12)
+#define F2FS_IOC_MOVE_RANGE		_IOWR(F2FS_IOCTL_MAGIC, 13,	\
+						struct f2fs_move_range)
+#else
 #define F2FS_IOC_START_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 3)
 #define F2FS_IOC_RELEASE_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 4)
 #define F2FS_IOC_ABORT_VOLATILE_WRITE	_IO(F2FS_IOCTL_MAGIC, 5)
@@ -270,6 +286,7 @@
 #define F2FS_IOC_DEFRAGMENT		_IO(F2FS_IOCTL_MAGIC, 8)
 #define F2FS_IOC_MOVE_RANGE		_IOWR(F2FS_IOCTL_MAGIC, 9,	\
 						struct f2fs_move_range)
+#endif
 
 #define F2FS_IOC_SET_ENCRYPTION_POLICY	FS_IOC_SET_ENCRYPTION_POLICY
 #define F2FS_IOC_GET_ENCRYPTION_POLICY	FS_IOC_GET_ENCRYPTION_POLICY
@@ -294,6 +311,24 @@
 #define F2FS_IOC32_GETVERSION		FS_IOC32_GETVERSION
 #endif
 
+#ifdef F2FS_MUFIT
+#define MUFIT_NODE_OFFSET	((((unsigned int)-2) << OFFSET_BIT_SHIFT) \
+				>> OFFSET_BIT_SHIFT)
+struct atomic_files_header {
+	struct list_head list;
+	unsigned int count_files;
+	unsigned int count_closed_files;
+	nid_t master_nid;
+	struct mufit_node mn;
+};
+
+struct atomic_files {
+	struct list_head list;
+	struct file *file;
+	bool closed;
+};
+#endif
+
 struct f2fs_defragment {
 	u64 start;
 	u64 len;
@@ -464,6 +499,12 @@
 	struct mutex inmem_lock;	/* lock for inmemory pages */
 	struct extent_tree *extent_tree;	/* cached extent_tree entry */
 	struct rw_semaphore dio_rwsem[2];/* avoid racing between dio and gc */
+
+#ifdef F2FS_MUFIT
+	pid_t af_list_owner_pid;
+	struct atomic_files_header *af_list_header;
+	struct atomic_files *af_list;
+#endif
 };
 
 static inline void get_extent_info(struct extent_info *ext,
@@ -1559,6 +1600,9 @@
 	FI_INLINE_DOTS,		/* indicate inline dot dentries */
 	FI_DO_DEFRAG,		/* indicate defragment is running */
 	FI_DIRTY_FILE,		/* indicate regular/symlink has dirty pages */
+#ifdef F2FS_MUFIT
+	FI_ADDED_ATOMIC_FILE,
+#endif
 };
 
 static inline void __mark_inode_dirty_flag(struct inode *inode,
@@ -1748,6 +1792,13 @@
 	return is_inode_flag_set(inode, FI_ATOMIC_FILE);
 }
 
+#ifdef F2FS_MUFIT
+static inline bool f2fs_is_added_atomic_file(struct inode *inode)
+{
+	return is_inode_flag_set(inode, FI_ADDED_ATOMIC_FILE);
+}
+#endif
+
 static inline bool f2fs_is_volatile_file(struct inode *inode)
 {
 	return is_inode_flag_set(inode, FI_VOLATILE_FILE);
@@ -1979,6 +2030,10 @@
 void move_node_page(struct page *, int);
 int fsync_node_pages(struct f2fs_sb_info *, struct inode *,
 			struct writeback_control *, bool);
+#ifdef F2FS_MUFIT
+int fsync_node_pages_atomic(struct f2fs_sb_info *, struct inode *,
+			struct writeback_control *, bool, struct atomic_files_header *);
+#endif
 int sync_node_pages(struct f2fs_sb_info *, struct writeback_control *);
 void build_free_nids(struct f2fs_sb_info *);
 bool alloc_nid(struct f2fs_sb_info *, nid_t *);
diff -urN original/fs/f2fs/file.c modified/fs/f2fs/file.c
--- original/fs/f2fs/file.c	2018-01-22 15:41:02.346194462 +0900
+++ modified/fs/f2fs/file.c	2018-01-30 22:06:36.556180651 +0900
@@ -32,6 +32,13 @@
 #include "trace.h"
 #include <trace/events/f2fs.h>
 
+#ifdef F2FS_MUFIT
+static int f2fs_ioc_add_atomic_file(struct file *filp, unsigned long arg);
+static int f2fs_ioc_start_atomic_files(unsigned long arg);
+static int f2fs_ioc_commit_atomic_files(unsigned long arg);
+static int f2fs_ioc_end_atomic_files(unsigned long arg);
+#endif
+
 static int f2fs_vm_page_mkwrite(struct vm_area_struct *vma,
 						struct vm_fault *vmf)
 {
@@ -287,6 +294,118 @@
 	return ret;
 }
 
+#ifdef F2FS_MUFIT
+static int f2fs_do_sync_files(struct file *file, loff_t start, loff_t end,
+				int datasync, bool last_file, struct atomic_files_header *af_header)
+{
+	struct inode *inode = file->f_mapping->host;
+	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
+	nid_t ino = inode->i_ino;
+	int ret = 0;
+	bool need_cp = false;
+	struct writeback_control wbc = {
+		.sync_mode = WB_SYNC_ALL,
+		.nr_to_write = LONG_MAX,
+		.for_reclaim = 0,
+	};
+
+	if (unlikely(f2fs_readonly(inode->i_sb)))
+		return 0;
+
+	trace_f2fs_sync_file_enter(inode);
+
+	/* if fdatasync is triggered, let's do in-place-update */
+	if (datasync || get_dirty_pages(inode) <= SM_I(sbi)->min_fsync_blocks)
+		set_inode_flag(inode, FI_NEED_IPU);
+	ret = filemap_write_and_wait_range(inode->i_mapping, start, end);
+	clear_inode_flag(inode, FI_NEED_IPU);
+
+	if (ret) {
+		trace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);
+		return ret;
+	}
+
+	/* if the inode is dirty, let's recover all the time */
+	if (!datasync && !f2fs_skip_inode_update(inode)) {
+		f2fs_write_inode(inode, NULL);
+		goto go_write;
+	}
+
+	/*
+	 * if there is no written data, don't waste time to write recovery info.
+	 */
+	if (!is_inode_flag_set(inode, FI_APPEND_WRITE) &&
+			!exist_written_data(sbi, ino, APPEND_INO)) {
+
+		/* it may call write_inode just prior to fsync */
+		if (need_inode_page_update(sbi, ino))
+			goto go_write;
+
+		if (is_inode_flag_set(inode, FI_UPDATE_WRITE) ||
+				exist_written_data(sbi, ino, UPDATE_INO))
+			goto flush_out;
+		goto out;
+	}
+go_write:
+	/*
+	 * Both of fdatasync() and fsync() are able to be recovered from
+	 * sudden-power-off.
+	 */
+	down_read(&F2FS_I(inode)->i_sem);
+	need_cp = need_do_checkpoint(inode);
+	up_read(&F2FS_I(inode)->i_sem);
+
+	if (need_cp) {
+		/* all the dirty node pages should be flushed for POR */
+		ret = f2fs_sync_fs(inode->i_sb, 1);
+
+		/*
+		 * We've secured consistency through sync_fs. Following pino
+		 * will be used only for fsynced inodes after checkpoint.
+		 */
+		try_to_fix_pino(inode);
+		clear_inode_flag(inode, FI_APPEND_WRITE);
+		clear_inode_flag(inode, FI_UPDATE_WRITE);
+		goto out;
+	}
+sync_nodes:
+	//ret = fsync_node_pages(sbi, inode, &wbc, atomic);
+	ret = fsync_node_pages_atomic(sbi, inode, &wbc, last_file, af_header);
+	if (ret)
+		goto out;
+
+	/* if cp_error was enabled, we should avoid infinite loop */
+	if (unlikely(f2fs_cp_error(sbi))) {
+		ret = -EIO;
+		goto out;
+	}
+
+	if (need_inode_block_update(sbi, ino) && last_file) {
+		f2fs_mark_inode_dirty_sync(inode);
+		f2fs_write_inode(inode, NULL);
+		goto sync_nodes;
+	}
+
+	ret = wait_on_node_pages_writeback(sbi, ino);
+	if (ret)
+		goto out;
+
+	/* once recovery info is written, don't need to tack this */
+	remove_ino_entry(sbi, ino, APPEND_INO);
+	clear_inode_flag(inode, FI_APPEND_WRITE);
+flush_out:
+	remove_ino_entry(sbi, ino, UPDATE_INO);
+	clear_inode_flag(inode, FI_UPDATE_WRITE);
+	if (last_file)
+		ret = f2fs_issue_flush(sbi);
+	f2fs_update_time(sbi, REQ_TIME);
+out:
+	trace_f2fs_sync_file_exit(inode, need_cp, datasync, ret);
+	f2fs_trace_ios(NULL, 1);
+	return ret;
+}
+#endif
+
 int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)
 {
 	return f2fs_do_sync_file(file, start, end, datasync, false);
@@ -1418,8 +1537,16 @@
 		return 0;
 
 	/* some remained atomic pages should discarded */
+#ifdef F2FS_MUFIT
+	if (f2fs_is_added_atomic_file(inode)) {
+	//	struct atomic_files_header *af_header = F2FS_I(inode)->af_list_header;
+	//		f2fs_ioc_end_atomic_files((unsigned long)&af_header->list);
+			clear_inode_flag(inode, FI_ADDED_ATOMIC_FILE);
+	}
+#endif
 	if (f2fs_is_atomic_file(inode))
 		drop_inmem_pages(inode);
+
 	if (f2fs_is_volatile_file(inode)) {
 		clear_inode_flag(inode, FI_VOLATILE_FILE);
 		set_inode_flag(inode, FI_DROP_CACHE);
@@ -1523,6 +1650,9 @@
 		goto out;
 
 	set_inode_flag(inode, FI_ATOMIC_FILE);
+#ifdef F2FS_MUFIT
+	F2FS_I(inode)->af_list_owner_pid = current->pid;
+#endif
 	f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);
 
 	if (!get_dirty_pages(inode))
@@ -1540,6 +1670,74 @@
 	return ret;
 }
 
+#ifdef F2FS_MUFIT
+static int f2fs_ioc_add_atomic_file(struct file *filp, unsigned long arg)
+{
+	struct list_head **atomic_list = (struct list_head**) arg;
+	struct atomic_files *new_file;
+	struct f2fs_inode_info *fi = F2FS_I(file_inode(filp));
+
+	if (f2fs_is_added_atomic_file(file_inode(filp))) {
+		//printk(KERN_DEBUG "[MUFIT DEBUG] The file is already added to another af_list\n");
+		return -EINVAL;
+	}
+
+	set_inode_flag(file_inode(filp), FI_ADDED_ATOMIC_FILE);
+
+	if ((*atomic_list) == NULL) {
+		struct atomic_files_header *af_header = 
+					(struct atomic_files_header*)kmalloc(sizeof(struct atomic_files_header), GFP_KERNEL);
+
+		if (af_header == NULL) {
+			printk(KERN_DEBUG "[MUFIT DEBUG] AF header creation failed\n");
+			return -ENOMEM;
+		}
+
+		INIT_LIST_HEAD(&af_header->list);
+		af_header->mn.count_valid_addr = cpu_to_le32(0);
+		af_header->count_files = 0;
+		af_header->count_closed_files = 0;
+		af_header->master_nid = 0;
+		*atomic_list = &af_header->list;
+	}
+
+	new_file = (struct atomic_files*)kmalloc(sizeof(struct atomic_files), GFP_KERNEL);
+
+	if (new_file == NULL) {
+		printk(KERN_DEBUG "[MUFIT DEBUG] AF list creation failed\n");
+		return -ENOMEM;
+	}
+
+	new_file->file = filp;
+	new_file->closed = false;
+	list_entry(*atomic_list, struct atomic_files_header, list)->count_files++;
+	list_add_tail(&new_file->list, *atomic_list);
+
+	fi->af_list_header = list_entry(*atomic_list, struct atomic_files_header, list);
+	fi->af_list = new_file;
+
+	return 0;
+}
+
+static int f2fs_ioc_start_atomic_files(unsigned long arg)
+{
+	struct list_head *atomic_list = (struct list_head*)arg;
+	struct atomic_files *current_file;
+	int ret;
+
+	if (!arg || !atomic_list) {
+		printk(KERN_DEBUG "[MUFIT DEBUG] atomic list is NULL\n");
+		return -ENOENT;
+	}
+
+	list_for_each_entry(current_file, atomic_list, list) {
+		ret = f2fs_ioc_start_atomic_write(current_file->file);
+	}
+
+	return ret;
+}
+#endif
+
 static int f2fs_ioc_commit_atomic_write(struct file *filp)
 {
 	struct inode *inode = file_inode(filp);
@@ -1564,6 +1762,9 @@
 			set_inode_flag(inode, FI_ATOMIC_FILE);
 			goto err_out;
 		}
+#ifdef F2FS_MUFIT
+		F2FS_I(inode)->af_list_owner_pid = 0;
+#endif
 	}
 
 	ret = f2fs_do_sync_file(filp, 0, LLONG_MAX, 0, true);
@@ -1573,6 +1774,100 @@
 	return ret;
 }
 
+#ifdef F2FS_MUFIT
+static int f2fs_ioc_commit_atomic_files(unsigned long arg)
+{
+	struct list_head* atomic_list = (struct list_head*) arg;
+	struct atomic_files* current_file;
+	struct atomic_files_header *af_header = 
+					list_entry(atomic_list, struct atomic_files_header, list);
+	struct inode *inode;
+	int ret;
+
+	if (!arg || !atomic_list) {
+		printk(KERN_DEBUG "[MUFIT DEBUG] atomic list is NULL\n");
+		return -ENOENT;
+	}
+
+	list_for_each_entry(current_file, atomic_list, list) {
+		inode = file_inode(current_file->file);
+
+		if(!inode_owner_or_capable(inode))
+			return -EACCES;
+
+		ret = mnt_want_write_file(current_file->file);
+		if (ret)
+			return ret;
+
+		inode_lock(inode);
+
+		if (f2fs_is_volatile_file(inode))
+			goto err_out;
+
+		if (f2fs_is_atomic_file(inode)) {
+			clear_inode_flag(inode, FI_ATOMIC_FILE);
+			ret = commit_inmem_pages(inode);
+			if (ret) {
+				set_inode_flag(inode, FI_ATOMIC_FILE);
+				goto err_out;
+			}
+			F2FS_I(inode)->af_list_owner_pid = 0;
+		}
+
+		ret = f2fs_do_sync_files(current_file->file, 0, LLONG_MAX, 0, 
+					current_file->list.next == atomic_list, af_header);
+
+err_out:
+		inode_unlock(inode);
+		mnt_drop_write_file(current_file->file);
+	}
+
+	af_header->mn.count_valid_addr = 0;
+
+	return ret;
+}
+
+static int f2fs_ioc_end_atomic_files(unsigned long arg)
+{
+	struct list_head *atomic_list = (struct list_head*)arg;
+	struct atomic_files_header *af_header = 
+			list_entry(atomic_list, struct atomic_files_header, list);
+	struct atomic_files *current_file;
+	struct atomic_files *temp;
+	struct page *page;
+	struct dnode_of_data dn;
+	struct inode *inode;
+
+	if (!arg || !atomic_list) {
+		printk(KERN_DEBUG "[MUFIT DEBUG] atomic list is NULL\n");
+		return -ENOENT;
+	}
+
+	list_for_each_entry_safe(current_file, temp, atomic_list, list) {
+		inode = file_inode(current_file->file);
+		if (!(current_file->closed))
+			clear_inode_flag(inode, FI_ADDED_ATOMIC_FILE);
+		kfree(current_file);
+	}
+
+	page = get_node_page(F2FS_I_SB(inode), af_header->master_nid);
+	if (IS_ERR(page)) {
+		return PTR_ERR(page);
+	}
+	else if (!page) {
+		kfree(af_header);
+		return -ENOENT;
+	}
+	set_new_dnode(&dn, inode, page, NULL, 0);
+	unlock_page(page);
+	truncate_node_atomic(&dn);
+
+	kfree(af_header );
+
+	return 0;
+}
+#endif
+
 static int f2fs_ioc_start_volatile_write(struct file *filp)
 {
 	struct inode *inode = file_inode(filp);
@@ -2197,6 +2492,16 @@
 long f2fs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
+#ifdef F2FS_MUFIT
+	case F2FS_IOC_ADD_ATOMIC_FILE:
+		return f2fs_ioc_add_atomic_file(filp, arg);
+	case F2FS_IOC_START_ATOMIC_WRITE_FILES:
+		return f2fs_ioc_start_atomic_files(arg);
+	case F2FS_IOC_COMMIT_ATOMIC_WRITE_FILES:
+		return f2fs_ioc_commit_atomic_files(arg);
+	case F2FS_IOC_END_ATOMIC_WRITE_FILES:
+		return f2fs_ioc_end_atomic_files(arg);
+#endif
 	case F2FS_IOC_GETFLAGS:
 		return f2fs_ioc_getflags(filp, arg);
 	case F2FS_IOC_SETFLAGS:
diff -urN original/fs/f2fs/node.c modified/fs/f2fs/node.c
--- original/fs/f2fs/node.c	2018-01-22 15:41:02.346194462 +0900
+++ modified/fs/f2fs/node.c	2018-01-30 11:12:01.629264313 +0900
@@ -24,6 +24,7 @@
 
 #define on_build_free_nids(nmi) mutex_is_locked(&nm_i->build_lock)
 
+extern void truncate_node_atomic(struct dnode_of_data *dn);
 static struct kmem_cache *nat_entry_slab;
 static struct kmem_cache *free_nid_slab;
 static struct kmem_cache *nat_entry_set_slab;
@@ -1412,6 +1413,143 @@
 	return ret ? -EIO: 0;
 }
 
+#ifdef F2FS_MUFIT
+int fsync_node_pages_atomic(struct f2fs_sb_info *sbi, struct inode *inode,
+		struct writeback_control *wbc, bool last_file, struct atomic_files_header *af_header)
+{
+	pgoff_t index, end;
+	struct pagevec pvec;
+	int ret = 0;
+	struct page *last_page = NULL;
+	bool marked = false;
+	nid_t ino = inode->i_ino;
+	bool fsynced = false;
+
+	last_page = last_fsync_dnode(sbi, ino);
+	if (IS_ERR_OR_NULL(last_page))
+		return PTR_ERR_OR_ZERO(last_page);
+retry:
+	pagevec_init(&pvec, 0);
+	index = 0;
+	end = ULONG_MAX;
+
+	while (index <= end) {
+		int i, nr_pages;
+		nr_pages = pagevec_lookup_tag(&pvec, NODE_MAPPING(sbi), &index,
+				PAGECACHE_TAG_DIRTY,
+				min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
+		if (nr_pages == 0)
+			break;
+
+		for (i = 0; i < nr_pages; i++) {
+			struct page *page = pvec.pages[i];
+
+			if (unlikely(f2fs_cp_error(sbi))) {
+				f2fs_put_page(last_page, 0);
+				pagevec_release(&pvec);
+				return -EIO;
+			}
+
+			if (!IS_DNODE(page) || !is_cold_node(page))
+				continue;
+			if (ino_of_node(page) != ino)
+				continue;
+
+			lock_page(page);
+
+			if (unlikely(page->mapping != NODE_MAPPING(sbi))) {
+continue_unlock:
+				unlock_page(page);
+				continue;
+			}
+			if (ino_of_node(page) != ino)
+				goto continue_unlock;
+
+			if (!PageDirty(page) && page != last_page) {
+				/* someone wrote it for us */
+				goto continue_unlock;
+			}
+
+			f2fs_wait_on_page_writeback(page, NODE, true);
+			BUG_ON(PageWriteback(page));
+
+			if (!clear_page_dirty_for_io(page))
+				goto continue_unlock;
+
+			ret = NODE_MAPPING(sbi)->a_ops->writepage(page, wbc);
+			if (ret) {
+				unlock_page(page);
+				f2fs_put_page(last_page, 0);
+				break;
+			}
+			if (page == last_page) {
+				nid_t nid;
+				struct node_info ni;
+
+				if (fsynced) {
+					marked = true;
+					break;
+				}
+
+				nid = nid_of_node(page);
+				get_node_info(sbi, nid, &ni);
+				af_header->mn.atm_addrs[af_header->mn.count_valid_addr++] = cpu_to_le32(ni.blk_addr);
+				f2fs_put_page(page, 0);
+				marked = true;
+
+				if (last_file) {
+					struct dnode_of_data dn;
+					bool is_nid_alloced = af_header->master_nid;
+
+					if (!is_nid_alloced) {
+						if (!alloc_nid(sbi, &(af_header->master_nid)))
+							return -ENOSPC;
+
+						set_new_dnode(&dn, inode, NULL, NULL, af_header->master_nid);
+						page = new_node_page(&dn, MUFIT_NODE_OFFSET, NULL);
+						if (IS_ERR(page)) {
+							alloc_nid_failed(sbi, af_header->master_nid);
+							af_header->master_nid = 0;
+							return PTR_ERR(page);
+						}
+						alloc_nid_done(sbi, af_header->master_nid);
+					}
+					else {
+						page = get_node_page(sbi, af_header->master_nid);
+					}
+
+					memcpy(page_address(page), &af_header->mn, sizeof(struct mufit_node));
+					set_fsync_mark(page, 1);
+					f2fs_put_page(page, 1);
+
+					marked = false;
+					fsynced = true;
+					last_page = page;
+				}
+
+				break;
+			}
+		}
+		pagevec_release(&pvec);
+		cond_resched();
+
+		if (ret || marked || fsynced)
+			break;
+	}
+	if (!ret && !marked) {
+		if (!fsynced)
+			f2fs_msg(sbi->sb, KERN_DEBUG,
+				"Retry to write fsync mark: ino=%u, idx=%lx",
+						ino, last_page->index);
+		lock_page(last_page);
+		set_page_dirty(last_page);
+		unlock_page(last_page);
+		goto retry;
+	}
+	return ret ? -EIO: 0;
+}
+#endif
+
 int sync_node_pages(struct f2fs_sb_info *sbi, struct writeback_control *wbc)
 {
 	pgoff_t index, end;
@@ -1595,6 +1733,7 @@
 		return 0;
 	}
 
+	//printk(KERN_DEBUG "[JATA DEBUG] (%s) nid: %u\n", __func__, nid);
 	set_page_writeback(page);
 	fio.old_blkaddr = ni.blk_addr;
 	write_node_page(nid, &fio);
@@ -1602,8 +1741,10 @@
 	dec_page_count(sbi, F2FS_DIRTY_NODES);
 	up_read(&sbi->node_write);
 
-	if (wbc->for_reclaim)
+	if (wbc->for_reclaim) {
+		//printk(KERN_DEBUG "[JATA DEBUG] (%s) for_reclaim is true\n", __func__);
 		f2fs_submit_merged_bio_cond(sbi, NULL, page, 0, NODE, WRITE);
+	}
 
 	unlock_page(page);
 
@@ -2390,3 +2531,10 @@
 	kmem_cache_destroy(free_nid_slab);
 	kmem_cache_destroy(nat_entry_slab);
 }
+
+#ifdef F2FS_MUFIT
+void truncate_node_atomic(struct dnode_of_data *dn)
+{
+	truncate_node(dn);
+}
+#endif
diff -urN original/fs/f2fs/node.h modified/fs/f2fs/node.h
--- original/fs/f2fs/node.h	2018-01-22 15:41:02.346194462 +0900
+++ modified/fs/f2fs/node.h	2018-01-23 22:31:49.713062462 +0900
@@ -334,6 +334,15 @@
 	return true;
 }
 
+#ifdef F2FS_MUFIT
+static inline bool IS_MUFIT_NODE(struct page *node_page)
+{
+	unsigned int ofs = ofs_of_node(node_page);
+
+	return ofs == MUFIT_NODE_OFFSET;
+}
+#endif
+
 static inline int set_nid(struct page *p, int off, nid_t nid, bool i)
 {
 	struct f2fs_node *rn = F2FS_NODE(p);
@@ -426,3 +435,7 @@
 }
 #define set_dentry_mark(page, mark)	set_mark(page, mark, DENT_BIT_SHIFT)
 #define set_fsync_mark(page, mark)	set_mark(page, mark, FSYNC_BIT_SHIFT)
+
+#ifdef F2FS_MUFIT
+extern void truncate_node_atomic(struct dnode_of_data *dn);
+#endif
diff -urN original/fs/f2fs/recovery.c modified/fs/f2fs/recovery.c
--- original/fs/f2fs/recovery.c	2018-01-22 15:41:02.346194462 +0900
+++ modified/fs/f2fs/recovery.c	2018-01-23 22:31:49.713062462 +0900
@@ -248,6 +248,59 @@
 		if (!is_fsync_dnode(page))
 			goto next;
 
+#ifdef F2FS_MUFIT
+		if (IS_MUFIT_NODE(page)) {
+			struct f2fs_node *rn = F2FS_NODE(page);
+			struct dnode_of_data dn;
+			struct page *atm_page;
+			int i;
+
+			for (i = 0; i<rn->mn.count_valid_addr; i++) {
+				if (!is_valid_blkaddr(sbi, rn->mn.atm_addrs[i], META_POR))
+					return 0;
+
+				atm_page = get_tmp_page(sbi, rn->mn.atm_addrs[i]);
+
+				if (cp_ver != cpver_of_node(atm_page))
+					goto next;
+
+				f2fs_put_page(atm_page, 1);
+			}
+
+			for (i = 0; i<rn->mn.count_valid_addr; i++) {
+				atm_page = get_tmp_page(sbi, rn->mn.atm_addrs[i]);
+
+				entry = get_fsync_inode(head, ino_of_node(atm_page));
+				if (entry) {
+					if (!is_same_inode(entry->inode, atm_page))
+						continue;
+				} else {
+					inode = f2fs_iget(sbi->sb, ino_of_node(atm_page));
+					if (IS_ERR(inode)) {
+						err = PTR_ERR(inode);
+						if (err == -ENOENT) {
+							err = 0;
+							goto next;
+						}
+						break;
+					}
+
+					entry = add_fsync_inode(head, inode);
+					if (!entry) {
+						err = -ENOMEM;
+						iput(inode);
+						break;
+					}
+				}
+				f2fs_put_page(atm_page, 1);
+			}
+			inode = f2fs_iget(sbi->sb, ino_of_node(page));
+			set_new_dnode(&dn, inode, page, NULL, 0);
+			truncate_node_atomic(&dn);
+			goto next;
+		}
+#endif
+
 		entry = get_fsync_inode(head, ino_of_node(page));
 		if (entry) {
 			if (!is_same_inode(entry->inode, page))
diff -urN original/include/linux/f2fs_fs.h modified/include/linux/f2fs_fs.h
--- original/include/linux/f2fs_fs.h	2018-01-22 15:41:02.346194462 +0900
+++ modified/include/linux/f2fs_fs.h	2018-01-22 15:41:02.346194462 +0900
@@ -14,6 +14,8 @@
 #include <linux/pagemap.h>
 #include <linux/types.h>
 
+#define F2FS_MUFIT_H
+
 #define F2FS_SUPER_OFFSET		1024	/* byte-size offset */
 #define F2FS_MIN_LOG_SECTOR_SIZE	9	/* 9 bits for 512 bytes */
 #define F2FS_MAX_LOG_SECTOR_SIZE	12	/* 12 bits for 4096 bytes */
@@ -249,12 +251,23 @@
 	__le32 next_blkaddr;	/* next node page block address */
 } __packed;
 
+#ifdef F2FS_MUFIT_H
+#define ADDRS_PER_MUFIT_NODE	(ADDRS_PER_BLOCK - 1)
+struct mufit_node {
+	__le32 count_valid_addr;
+	__le32 atm_addrs[ADDRS_PER_MUFIT_NODE];
+} __packed;
+#endif
+
 struct f2fs_node {
 	/* can be one of three types: inode, direct, and indirect types */
 	union {
 		struct f2fs_inode i;
 		struct direct_node dn;
 		struct indirect_node in;
+#ifdef F2FS_MUFIT_H
+		struct mufit_node mn;
+#endif
 	};
 	struct node_footer footer;
 } __packed;
